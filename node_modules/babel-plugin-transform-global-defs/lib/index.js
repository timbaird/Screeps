'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref /*:PluginOptions*/) {
  let t = _ref.types;

  let globalDefs /*:Object*/ = {};
  let deopts /*:string[]*/ = [];

  let _definitions /*:[[string, mixed]]*/ = [];
  let definitions /*:[{
                  root:string,
                  expr: string,
                  value: mixed,
                  allExpr: [string]
                  }]*/ = [];

  function deopt(expr /*:string*/) {
    // debug
    // console.log('deopting', expr);
    deopts.push(expr);
  }

  function isDeopt(expr /*:string*/) /*:bool*/{
    for (let i = 0; i < deopts.length; i++) {
      if (expr.indexOf(deopts[i]) !== -1) {
        return true;
      }
    }
    return false;
  }

  return {
    visitor: {
      Program: function Program(path /*:NodePath*/) {
        var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? /*:GlobalDefsOptions*/{} : arguments[1];

        var _ref2$opts = _ref2.opts;
        _ref2$opts = _ref2$opts === undefined ? {} : _ref2$opts;
        var _ref2$opts$global_def = _ref2$opts.global_defs;
        let global_defs = _ref2$opts$global_def === undefined ? {} : _ref2$opts$global_def;

        // validate it's a plain object
        if (!global_defs || typeof global_defs !== 'object' || Array.isArray(global_defs)) {
          throw new Error('global_defs must be a Plain Object');
        }
        // validate that there are no circular references
        if (hasCircularReference(global_defs)) {
          throw new Error('global_defs has a circular referece');
        }

        globalDefs = global_defs;

        // !important
        // flush the deopts, otherwise it is preserved in memory
        deopts = [];

        _definitions = getAllPaths(globalDefs);
        definitions = _definitions.map(defn => {
          const root /*:string*/ = defn[0];

          var _getExpressionFromPat = getExpressionFromPath(defn);

          const expr = _getExpressionFromPat.expr;
          const value = _getExpressionFromPat.value;

          const allExpr = getAllExpressionsFromPath(defn);
          return { root: root, expr: expr, value: value, allExpr: allExpr };
        });
      },


      // TODO
      // UpdateExpression x++ things

      AssignmentExpression: function AssignmentExpression(path /*:NodePath*/) {
        const left = path.get('left');

        definitions.forEach(_ref3 => {
          let root = _ref3.root;
          let allExpr = _ref3.allExpr;

          allExpr.forEach(expr => {
            let match = false;

            if (left.isIdentifier()) {
              if (left.node.name === expr) {
                match = true;
              }
            } else if (left.isMemberExpression()) {
              if (left.matchesPattern(expr)) {
                match = true;
              }
            }

            // debug
            // if (match) {
            //   console.log(
            //     "AssignmentExpression",
            //     !path.scope.hasBinding(root),
            //     path.scope.hasGlobal(root),
            //     isDeopt(expr)
            //   );
            // }

            if (!path.scope.hasBinding(root) && path.scope.hasGlobal(root) && match && !isDeopt(expr)) {
              deopt(expr);
            }
          });
        });
      },


      Identifier: {
        exit: function exit(path /*:NodePath*/) {

          // replaceable paths
          let replaceablePaths = ['BinaryExpression', 'LogicalExpression', 'ExpressionStatement', 'Conditional', 'SwitchStatement', 'SwitchCase', 'WhileStatement', 'DoWhileStatement', 'ForStatement'];

          let replaceable = false;

          for (let i of replaceablePaths) {
            if (path.parentPath['is' + i]()) {
              replaceable = true;
            }
          }

          if (!replaceable) return;

          definitions.filter(_ref4 => {
            let root = _ref4.root;
            let expr = _ref4.expr;
            return root === expr;
          }).forEach(_ref5 => {
            let root = _ref5.root;
            let value = _ref5.value;

            if (!path.scope.hasBinding(root) && path.scope.hasGlobal(root) && !isDeopt(root)) {
              path.replaceWith(t.valueToNode(value));
            }
          });
        }
      },

      MemberExpression: {
        exit: function exit(path /*:NodePath*/) {
          definitions.filter(_ref6 => {
            let root = _ref6.root;
            let expr = _ref6.expr;
            return root !== expr;
          }).forEach(_ref7 => {
            let root = _ref7.root;
            let expr = _ref7.expr;
            let value = _ref7.value;

            // debug
            // if (path.matchesPattern(expr)) {
            //   console.log(
            //     !path.scope.hasBinding(root)
            //     , path.scope.hasGlobal(root)
            //     , !isDeopt(expr)
            //   );
            // }

            if (path.matchesPattern(expr) && !path.scope.hasBinding(root) && path.scope.hasGlobal(root) && !isDeopt(expr)) {
              path.replaceWith(t.valueToNode(value));
            }
          });
        }
      }
    }
  };
};

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } } // @flow
/*::import type {NodePath, Binding, Scope, Node, PluginOptions} from 'Babel';*/


function hasCircularReference(obj /*:Object*/) /*:bool*/{
  let visited = [];
  function walk(o) {
    if (o && typeof o === 'object') {
      if (visited.indexOf(o) !== -1) {
        return true;
      }
      visited.push(o);
      for (let key in o) {
        if (Object.hasOwnProperty.call(o, key) && walk(o[key])) {
          // debug
          // console.log('CircularReference at ' + key);
          return true;
        }
      }
    }
    return false;
  }
  return walk(obj);
}

function getAllPaths(obj /*:Object*/) /*:[[string, mixed]] */{
  let paths /*[[string, mixed]]*/ = [];
  function walk(o) {
    let state /*:[number|string]*/ = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

    if (o && typeof o === 'object') {
      if (Array.isArray(o)) {
        for (let i = 0; i < o.length; i++) {
          walk(o[i], [].concat(_toConsumableArray(state), [i]));
        }
      } else {
        for (let key in o) {
          if (Object.hasOwnProperty.call(o, key)) {
            walk(o[key], [].concat(_toConsumableArray(state), [key]));
          }
        }
      }
    } else {
      paths.push([].concat(_toConsumableArray(state), [o]));
    }
  }
  walk(obj);
  return paths;
}

function exprToString(expr /*:[string, mixed]*/) /*:string*/{
  return expr.reduce((p, c) => {
    if (typeof c === 'number') {
      return `${ p }[${ c }]`;
    } else if (typeof c === 'string') {
      return p ? p + '.' + c : c;
    } else {
      throw new TypeError('Somehow value of expression came in to expression');
    }
  }, '');
}

function getExpressionFromPath(path /*:[string, mixed]*/) /*:{expr: string, value: mixed}*/{
  let _expr = [].concat(_toConsumableArray(path));
  const value /*:mixed*/ = _expr.pop();
  let expr = exprToString(_expr);
  return { expr: expr, value: value };
}

function getAllExpressionsFromPath(path /*:[string, mixed]*/) /*:string[]*/{
  let _expr = [].concat(_toConsumableArray(path));
  _expr.pop(); // remove value
  let possibilities = [];
  for (let i = 0; i < _expr.length; i++) {
    possibilities.push(_expr.slice(0, i + 1));
  }
  return possibilities.map(e => exprToString(e));
}
module.exports = exports['default'];