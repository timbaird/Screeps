'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Mangle;

var _namegen = require('./namegen');

var _namegen2 = _interopRequireDefault(_namegen);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 * These entities can have a `name` property which should be preserved when
 * `keep_fnames` is true.
 *
 * Arrow functions don't have a name.
 *
 * Methods are anyway not renamed as they are object properties
 *
 */
function isFunction(binding /* :Binding */) /*:boolean*/{
  return binding.path.isFunctionExpression() || binding.path.isFunctionDeclaration() || binding.path.isClassDeclaration() || binding.path.isClassExpression();
} // @flow
/*::import type {NodePath, Binding, Scope, Node, PluginOptions} from 'Babel';*/


function renameIdentifiers(path /* :NodePath */) {
  var _ref = arguments.length <= 1 || arguments[1] === undefined ? /*:ManglerOptions*/{} : arguments[1];

  var _ref$opts = _ref.opts;
  _ref$opts = _ref$opts === undefined ? {} : _ref$opts;
  var _ref$opts$keep_fnames = _ref$opts.keep_fnames;
  let keep_fnames = _ref$opts$keep_fnames === undefined ? false : _ref$opts$keep_fnames;

  const bindings /* :Object */ = path.scope.getAllBindings();

  const ownBindings /* :string[] */ = Object.keys(bindings).filter(b => path.scope.hasOwnBinding(b));
  const names = (0, _namegen2.default)();

  ownBindings
  /**
   * If the binding is already just 1 character long,
   * there is no point in mangling - also, this saves us from expiring the
   * single character names during multiple passes.
   */
  .filter(b => b.length !== 1)
  /**
   * keep_fnames
   * This is useful for functions which depend on fn.name
   */
  .filter(b => {
    if (!keep_fnames) return true;
    const binding = path.scope.getBinding(b);
    if (!binding) {
      throw new TypeError('[mangle] Unexpected error. Binding not found');
    }
    return !isFunction(binding);
  })
  /**
   * Iterate through the possible names one by one until we
   * find a suitable binding that doesn't conflict with existing ones
   */
  .map(b => {
    let _next = names.next();
    if (_next.done) throw new Error('Name generator stopped');

    let next /*:string*/ = _next.value;
    while (path.scope.hasBinding(next) || path.scope.hasGlobal(next) || path.scope.hasReference(next)) {
      _next = names.next();
      if (_next.done) throw new Error('Name generator stopped');
      next = _next.value;
    }
    path.scope.rename(b, next);
  });
}

/**
 * Mangle Plugin
 */
function Mangle() {
  return {
    visitor: {
      Program: function Program(path /*:NodePath*/, options /*:ManglerOptions*/) {
        if (options.opts && options.opts.mangle_globals) renameIdentifiers(path, options);
      },

      BlockStatement: renameIdentifiers
    }
  };
}
module.exports = exports['default'];